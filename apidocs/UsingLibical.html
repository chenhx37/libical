<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libical API Documentation: Using Libical</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Libical API Documentation
   &#160;<span id="projectnumber">3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using Libical </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_allen_projects_libical_libical_doc_UsingLibical"></a> </p><blockquote class="doxtable">
<p>Author: Eric Busboom <a href="#" onclick="location.href='mai'+'lto:'+'eri'+'c@'+'civ'+'ic'+'kno'+'wl'+'edg'+'e.'+'com'; return false;">eric@<span style="display: none;">.nosp@m.</span>civi<span style="display: none;">.nosp@m.</span>cknow<span style="display: none;">.nosp@m.</span>ledg<span style="display: none;">.nosp@m.</span>e.com</a></p>
<p>Date: January 2001 </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md85"></a>
1 Introduction</h1>
<p>Libical is an Open Source implementation of the iCalendar protocols and protocol data units. The iCalendar specification describes how calendar clients can communicate with calendar servers so users can store their calendar data and arrange meetings with other users.</p>
<p>Libical implements <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a>, <a href="https://tools.ietf.org/html/rfc5546">RFC5546</a>, <a href="https://tools.ietf.org/html/rfc7529">RFC7529</a>; the CalDav scheduling extensions in <a href="https://tools.ietf.org/html/rfc6638">RFC6638</a>; the iCalendar extensions in [RFC7986][], <a href="https://tools.ietf.org/html/rfc9073">RFC9073</a>, <a href="https://tools.ietf.org/html/rfc9074">RFC9074</a>; and some of <a href="https://tools.ietf.org/html/rfc6047">RFC6047</a>.</p>
<p>This documentation assumes that you are familiar with the iCalendar standards RFC5545 and RFC5546. These specifications are available at the <a href="https://tools.ietf.org/">IETF Tools</a> website:</p>
<h2><a class="anchor" id="autotoc_md86"></a>
1.1 The libical project</h2>
<p>This code is under active development. If you would like to contribute to the project, visit <a href="https://libical.github.io/libical/">https://libical.github.io/libical/</a>.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
1.2 License</h2>
<p>The code and datafiles in this distribution are licensed under the Mozilla Public License version 2.0. See <a href="https://www.mozilla.org/MPL">https://www.mozilla.org/MPL</a> for a copy of the license. Alternately, you may use libical under the terms of the GNU Lesser General Public License, version 2.1. See <a href="https://www.gnu.org/licenses/lgpl-2.1.html">https://www.gnu.org/licenses/lgpl-2.1.html</a> for a copy of the LGPL.</p>
<p>This dual license ensures that the library can be incorporated into both proprietary code and GPL'd programs, and will benefit from improvements made by programmers in both realms. I will only accept changes into my version of the library if they are similarly dual-licensed.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
1.3 Example Code</h2>
<p>A lot of the documentation for this library is in the form of example code. These examples are in the <code>examples/</code> directory of the distribution. Also look in <code>src/test/</code> for additional annotated examples.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
2 Building the Library</h1>
<p>Libical uses autoconf to generate makefiles. It should build with no adjustments on Linux, FreeBSD and Solaris under <code>gcc</code>. Some versions have been successfully built on MacOS, Solaris, UnixWare, And Tru64 UNIX without <code>gcc</code>, but you may run into problems with a particular later version.</p>
<p>For a more complete guide to building the library, see the <code>README</code> file in the distribution.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
3 Structure</h1>
<p>The iCalendar data model is based on four types of objects: <em>components</em>, <em>properties</em>, <em>values</em> and <em>parameters</em>.</p>
<p>Properties are the fundamental unit of information in iCalendar, and they work a bit like a hash entry, with a constant key and a variable value. Properties may also have modifiers, called parameters. In the iCal content line</p>
<div class="fragment"><div class="line">ORGANIZER;ROLE=CHAIR:MAILTO:mrbig@host.com</div>
</div><!-- fragment --><p>The property name is <code>ORGANIZER</code>, the value of the property is <code>mrbig@host.com</code> and the <code>ROLE</code> parameter specifies that Mr Big is the chair of the meetings associated with this property.</p>
<p>Components are groups of properties that represent the core objects of a calendar system, such as events or timezones. Components are delimited by <code>BEGIN</code> and <code>END</code> tags.</p>
<p>When a component is sent across a network, if it is un-encrypted, it will look something like:</p>
<div class="fragment"><div class="line">BEGIN:VCALENDAR</div>
<div class="line">METHOD:REQUEST</div>
<div class="line">PRODID: -//hacksw/handcal//NONSGML v1.0//EN</div>
<div class="line">BEGIN:VEVENT</div>
<div class="line">DTSTAMP:19980309T231000Z</div>
<div class="line">UID:guid-1.host1.com</div>
<div class="line">ORGANIZER;ROLE=CHAIR:MAILTO:mrbig@host.com</div>
<div class="line">ATTENDEE;RSVP=TRUE;ROLE=REQ-PARTICIPANT;CUTYPE=GROUP:</div>
<div class="line">  MAILTO:employee-A@host.com</div>
<div class="line">DESCRIPTION:Project XYZ Review Meeting</div>
<div class="line">CATEGORIES:MEETING</div>
<div class="line">CLASS:PUBLIC</div>
<div class="line">CREATED:19980309T130000Z</div>
<div class="line">SUMMARY:XYZ Project Review</div>
<div class="line">DTSTART;TZID=US-Eastern:19980312T083000</div>
<div class="line">DTEND;TZID=US-Eastern:19980312T093000</div>
<div class="line">LOCATION:1CP Conference Room 4350</div>
<div class="line">END:VEVENT</div>
<div class="line">END:VCALENDAR</div>
</div><!-- fragment --><p>Note that components can be nested; this example has both a VCALENDAR and a VEVENT component, one nested inside the other.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
3.1 Core iCal classes</h2>
<p>Libical is an object-based, data-oriented library. Nearly all of the routines in the library are associated with an opaque data types and perform some operation on that data type. Although the library does not actually have classes, we will use those terms since the behavior of these associations of data and routines is very similar to a class.</p>
<h3><a class="anchor" id="autotoc_md92"></a>
3.1.1 Properties</h3>
<p>Properties are represented with the <code>icalproperty</code> class and its many "derived" classes with one "derived" class per property type in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a>. Again, there is no actual inheritance relations, but there are clusters of routines that make this term useful. A property is a container for a single value and a set of parameters.</p>
<h3><a class="anchor" id="autotoc_md93"></a>
3.1.2 Components</h3>
<p>In libical, components are represented with the <code>icalcomponent</code> class. <code>icalcomponent</code> is a container for a set of other components and properties.</p>
<h3><a class="anchor" id="autotoc_md94"></a>
3.1.3 Values</h3>
<p>Values are represented in a similar way to properties; a base class and many "derived " classes. A value is essentially a abstract handle on a single fundamental type, a structure or a union.</p>
<h3><a class="anchor" id="autotoc_md95"></a>
3.1.4 Parameters</h3>
<p>Parameters are represented in a similar way to properties, except that they contain only one value.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
3.2 Other elements of libical</h2>
<p>In addition to the core iCal classes, libical has many other types, structures, and classes that aid in creating and using iCal components.</p>
<h3><a class="anchor" id="autotoc_md97"></a>
3.2.1 Enumerations and types</h3>
<p>Libical is strongly typed, so every component, property, parameter, and value type has an enumeration, and some have an associated structure or union.</p>
<h3><a class="anchor" id="autotoc_md98"></a>
3.2.2 The parser</h3>
<p>The libical parser offers a variety of ways to convert <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> text into a libical internal component structure. The parser can parse blocks of text as a string, or it can parse line-by-line.</p>
<h3><a class="anchor" id="autotoc_md99"></a>
3.2.3 Error objects</h3>
<p>Libical has a substantial error reporting system for both programming errors and component usage errors.</p>
<h3><a class="anchor" id="autotoc_md100"></a>
3.2.4 Memory Management</h3>
<p>Since many of libical's interfaces return strings, the library has its own memory management system to eliminate the need to free every string returned from the library.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
3.2.5 Storage classes</h3>
<p>The library also offers several classes to store components to files, memory or databases.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
4 Differences From RFCs</h1>
<p>Libical has been designed to follow the standards as closely as possible, so that the key objects in the standards are also key objects in the library. However, there are a few areas where the specifications are (arguably) irregular, and following them exactly would result in an unfriendly interface. These deviations make libical easier to use by maintaining a self-similar interface.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
4.1 Pseudo Components</h2>
<p>Libical defines components for groups of properties that look and act like components, but are not defined as components in the specification. <code>XDAYLIGHT</code> and <code>XSTANDARD</code> are notable examples. These pseudo components group properties within the <code>VTIMEZONE</code> components. For instanace, the timezone properties associated with daylight savings time starts with <code>BEGIN:DAYLIGHT</code> and ends with <code>END:DAYLIGHT</code>, just like other components, but is not defined as a component in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> (see <a href="https://tools.ietf.org/html/rfc5545#section-3.6.5&gt;">section 3.6.5</a>) In libical, this grouping is represented by the <code>XDAYLIGHT</code> component. Standard iCal components all start with the letter "V," while pseudo components start with "X."</p>
<p>There are also pseudo components that are conceptually derived classes of <code>VALARM</code>. <a href="https://tools.ietf.org/html/rfc5546">RFC5546</a> defines what properties may be included in each component, and for <code>VALARM</code>, the set of properties it may have depends on the value of the <code>ACTION</code> property.</p>
<p>For instance, if a <code>VALARM</code> component has an <code>ACTION</code> property with the value of <code>AUDIO</code>, the component must also have an <code>ATTACH</code> property. However, if the <code>ACTION</code> value is <code>DISPLAY</code>, the component must have a <code>DESCRIPTION</code> property.</p>
<p>To handle these various, complex restrictions, libical has pseudo components for each type of alarm: <code>XAUDIOALARM</code>, <code>XDISPLAYALARM</code>, <code>XEMAILALARM</code> and <code>XPROCEDUREALARM</code>.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
4.2 Combined Values</h2>
<p>Many values can take more than one type. <code>TRIGGER</code>, for instance, can have a value type of with <code>DURATION</code> or of <code>DATE-TIME</code>. These multiple types make it difficult to create routines to return the value associated with a property.</p>
<p>It is natural to have interfaces that would return the value of a property, but it is cumbersome for a single routine to return multiple types. So, in libical, properties that can have multiple types are given a single type that is the union of their RFC5545 types. For instance, in libical, the value of the <code>TRIGGER</code> property resolves to struct <code>icaltriggertype</code>. This type is a union of a <code>DURATION</code> and a <code>DATE-TIME</code>.</p>
<h2><a class="anchor" id="autotoc_md105"></a>
4.3 Multi-Valued Properties</h2>
<p>Some properties, such as <code>CATEGORIES</code> have only one value type, but each <code>CATEGORIES</code> property can have multiple value instances. This also results in a cumbersome interface &ndash; <code>CATEGORIES</code> accessors would have to return a list while all other accessors returned a single value. In libical, all properties have a single value, and multi-valued properties are broken down into multiple single valued properties during parsing. That is, an input line like,</p>
<div class="fragment"><div class="line">CATEGORIES: work, home</div>
</div><!-- fragment --><p>becomes in libical's internal representation</p>
<div class="fragment"><div class="line">CATEGORIES: work</div>
<div class="line">CATEGORIES: home</div>
</div><!-- fragment --><p>Oddly, <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> allows some multi-valued properties (like <code>FREEBUSY</code>) to exist as both a multi-values property and as multiple single value properties, while others (like <code>CATEGORIES</code>) can only exist as single multi-valued properties. This makes the internal representation for <code>CATEGORIES</code> illegal. However when you convert a component to a string, the library will collect all of the <code>CATEGORIES</code> properties into one.</p>
<h1><a class="anchor" id="autotoc_md106"></a>
5 Using libical</h1>
<h2><a class="anchor" id="autotoc_md107"></a>
5.1 Creating Components</h2>
<p>There are three ways to create components in Libical:</p><ol type="1">
<li>creating individual objects and assembling them,</li>
<li>building entire objects in massive vaargs calls,</li>
<li>and parsing a text file containing iCalendar data.</li>
</ol>
<h3><a class="anchor" id="autotoc_md108"></a>
5.1.1 Constructor Interfaces</h3>
<p>Using constructor interfaces, you create each of the objects separately and then assemble them in to components:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *event;</div>
<div class="line">icalproperty *prop;</div>
<div class="line">icalparameter *param;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> atime;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create new VEVENT component</span></div>
<div class="line"><span class="keyword">event</span> = <a class="code" href="icalcomponent_8h.html#a601ce104db17e96574387a14a8bcde86">icalcomponent_new</a>(ICAL_VEVENT_COMPONENT);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add DTSTAMP property to the event</span></div>
<div class="line">prop = icalproperty_new_dtstamp(atime);</div>
<div class="line">icalcomponent_add_property(event, prop);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add UID property to the event</span></div>
<div class="line">prop = icalproperty_new_uid(<span class="stringliteral">&quot;guid-1.example.com&quot;</span>);</div>
<div class="line">icalcomponent_add_property(event, prop);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add ORGANIZER (with ROLE=CHAIR) to the event</span></div>
<div class="line">prop = icalproperty_new_organizer(<span class="stringliteral">&quot;mrbig@example.com&quot;</span>);</div>
<div class="line">param = icalparameter_new_role(ICAL_ROLE_CHAIR);</div>
<div class="line">icalproperty_add_parameter(prop, param);</div>
<div class="line">icalcomponent_add_property(event, prop);</div>
<div class="ttc" id="aicalcomponent_8h_html_a601ce104db17e96574387a14a8bcde86"><div class="ttname"><a href="icalcomponent_8h.html#a601ce104db17e96574387a14a8bcde86">icalcomponent_new</a></div><div class="ttdeci">icalcomponent * icalcomponent_new(icalcomponent_kind kind)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icalcomponent.c:111</div></div>
<div class="ttc" id="astructicalcomponent__impl_html"><div class="ttname"><a href="structicalcomponent__impl.html">icalcomponent_impl</a></div><div class="ttdef"><b>Definition:</b> icalcomponent.c:36</div></div>
<div class="ttc" id="astructicaltimetype_html"><div class="ttname"><a href="structicaltimetype.html">icaltimetype</a></div><div class="ttdef"><b>Definition:</b> icaltime.h:105</div></div>
</div><!-- fragment --><p>Notice that libical uses a semi-object-oriented style of interface. Most things you work with are objects, that are instantiated with a constructor that has "new" in the name. Also note that, other than the object reference, most structure data is passed in to libical routines by value. Libical has some complex but very regular memory handling rules. These are detailed in section [sec:memory].</p>
<p>If any of the constructors fail, they will return 0. If you try to insert 0 into a property or component, or use a zero-valued object reference, libical will either silently ignore the error or will abort with an error message. This behavior is controlled by a compile time flag (<code>ICAL_ERRORS_ARE_FATAL</code>), and will abort by default.</p>
<h3><a class="anchor" id="autotoc_md109"></a>
5.1.2 varargs Constructors</h3>
<p>There is another way to create complex components, which is arguably more elegant, if you are not horrified by varargs. The varargs constructor interface allows you to create intricate components in a single block of code. Here is the previous examples in the vaargs style.</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *calendar;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> atime;</div>
<div class="line"> </div>
<div class="line">calendar =</div>
<div class="line">    <a class="code" href="icalcomponent_8h.html#a17434ae44b07679a5d9aa521e91a5ec6">icalcomponent_vanew</a>(</div>
<div class="line">        ICAL_VCALENDAR_COMPONENT,</div>
<div class="line">        icalproperty_new_version(<span class="stringliteral">&quot;2.0&quot;</span>),</div>
<div class="line">        icalproperty_new_prodid(</div>
<div class="line">             <span class="stringliteral">&quot;-//RDU Software//NONSGML HandCal//EN&quot;</span>),</div>
<div class="line">        <a class="code" href="icalcomponent_8h.html#a17434ae44b07679a5d9aa521e91a5ec6">icalcomponent_vanew</a>(</div>
<div class="line">            ICAL_VEVENT_COMPONENT,</div>
<div class="line">            icalproperty_new_dtstamp(atime),</div>
<div class="line">            icalproperty_new_uid(<span class="stringliteral">&quot;guid-1.host1.com&quot;</span>),</div>
<div class="line">            icalproperty_vanew_organizer(</div>
<div class="line">                <span class="stringliteral">&quot;mrbig@host.com&quot;</span>,</div>
<div class="line">                icalparameter_new_role(ICAL_ROLE_CHAIR),</div>
<div class="line">                NULL),</div>
<div class="line">            icalproperty_vanew_attendee(</div>
<div class="line">                <span class="stringliteral">&quot;employee-A@host.com&quot;</span>,</div>
<div class="line">                icalparameter_new_role(</div>
<div class="line">                    ICAL_ROLE_REQPARTICIPANT),</div>
<div class="line">                icalparameter_new_rsvp(1),</div>
<div class="line">                icalparameter_new_cutype(ICAL_CUTYPE_GROUP),</div>
<div class="line">                NULL),</div>
<div class="line">            icalproperty_new_location(</div>
<div class="line">               <span class="stringliteral">&quot;1CP Conference Room 4350&quot;</span>),</div>
<div class="line">            NULL),</div>
<div class="line">        NULL);</div>
<div class="ttc" id="aicalcomponent_8h_html_a17434ae44b07679a5d9aa521e91a5ec6"><div class="ttname"><a href="icalcomponent_8h.html#a17434ae44b07679a5d9aa521e91a5ec6">icalcomponent_vanew</a></div><div class="ttdeci">icalcomponent * icalcomponent_vanew(icalcomponent_kind kind,...)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icalcomponent.c:118</div></div>
</div><!-- fragment --><p>This form is similar to the constructor form, except that the constructors have <code>vanew</code> instead of <code>new</code> in the name. The arguments are similar too, except that the component constructor can have a list of properties, and the property constructor can have a list of parameters.</p>
<p><em>Be sure to terminate every list with a <code>NULL</code> (or a *<code>(void 0)</code></em>, or your code will crash, if you are lucky*. The reason you can't use 0 itself is that depending on what platform you are on, <code>sizeof(int) ≠ sizeof(void*)</code>.</p>
<h3><a class="anchor" id="autotoc_md110"></a>
5.1.3 Parsing Text Files</h3>
<p>The final way to create components will probably be the most common; you can create components from <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> compliant text. If you have the string in memory, use</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* <a class="code" href="icalparser_8h.html#a966f6fd4bc931c06b2c596daeadb692f">icalparser_parse_string</a>(<span class="keywordtype">char</span>* str);</div>
<div class="ttc" id="aicalparser_8h_html_a966f6fd4bc931c06b2c596daeadb692f"><div class="ttname"><a href="icalparser_8h.html#a966f6fd4bc931c06b2c596daeadb692f">icalparser_parse_string</a></div><div class="ttdeci">icalcomponent * icalparser_parse_string(const char *str)</div><div class="ttdoc">Parses a string and returns the parsed ::icalcomponent.</div><div class="ttdef"><b>Definition:</b> icalparser.c:1356</div></div>
</div><!-- fragment --><p>If the string contains only one component, the parser will return the component in libical form. If the string contains multiple components, the multiple components will be returned as the children of an <code>ICAL_XROOT_COMPONENT</code> component.</p>
<p>Parsing a whole string may seem wasteful if you want to pull a large component off of the network or from a file; you may prefer to parse the component line by line. This is possible too by using:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalparser__impl.html">icalparser</a>* <a class="code" href="icalparser_8h.html#a3a7a45307a9ff90ec23d632501c0bd00">icalparser_new</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="icalparser_8h.html#a1cb8b8678b781d3d2ede0fbce613b90d">icalparser_free</a>(</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a>* parser);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalparser_8h.html#a1e9b165c1aa2ba82605bcccadf85f74c">icalparser_get_line</a>(</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser,</div>
<div class="line">    <span class="keywordtype">char</span>* (*read_stream)(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size,  <span class="keywordtype">void</span>* d));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalparser_8h.html#a1138735cde70554bcdfc17dc8a595a6a">icalparser_add_line</a>(</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser,</div>
<div class="line">    <span class="keywordtype">char</span> *line);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689">icalparser_set_gen_data</a>(</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser,</div>
<div class="line">    <span class="keywordtype">void</span> *data);</div>
<div class="ttc" id="aicalparser_8h_html_a1138735cde70554bcdfc17dc8a595a6a"><div class="ttname"><a href="icalparser_8h.html#a1138735cde70554bcdfc17dc8a595a6a">icalparser_add_line</a></div><div class="ttdeci">icalcomponent * icalparser_add_line(icalparser *parser, char *str)</div><div class="ttdoc">Adds a single line to be parsed by the icalparser.</div><div class="ttdef"><b>Definition:</b> icalparser.c:702</div></div>
<div class="ttc" id="aicalparser_8h_html_a1cb8b8678b781d3d2ede0fbce613b90d"><div class="ttname"><a href="icalparser_8h.html#a1cb8b8678b781d3d2ede0fbce613b90d">icalparser_free</a></div><div class="ttdeci">void icalparser_free(icalparser *parser)</div><div class="ttdoc">Frees an icalparser object.</div><div class="ttdef"><b>Definition:</b> icalparser.c:124</div></div>
<div class="ttc" id="aicalparser_8h_html_a1e9b165c1aa2ba82605bcccadf85f74c"><div class="ttname"><a href="icalparser_8h.html#a1e9b165c1aa2ba82605bcccadf85f74c">icalparser_get_line</a></div><div class="ttdeci">char * icalparser_get_line(icalparser *parser, icalparser_line_gen_func line_gen_func)</div><div class="ttdoc">Given a line generator function, returns a single iCal content line.</div><div class="ttdef"><b>Definition:</b> icalparser.c:487</div></div>
<div class="ttc" id="aicalparser_8h_html_a3a7a45307a9ff90ec23d632501c0bd00"><div class="ttname"><a href="icalparser_8h.html#a3a7a45307a9ff90ec23d632501c0bd00">icalparser_new</a></div><div class="ttdeci">icalparser * icalparser_new(void)</div><div class="ttdoc">Creates a new icalparser.</div><div class="ttdef"><b>Definition:</b> icalparser.c:101</div></div>
<div class="ttc" id="aicalparser_8h_html_aae6d08b4084610e225621a25dddd7689"><div class="ttname"><a href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689">icalparser_set_gen_data</a></div><div class="ttdeci">void icalparser_set_gen_data(icalparser *parser, void *data)</div><div class="ttdoc">Sets the data that icalparser_parse will give to the line_gen_func as the parameter 'd'.</div><div class="ttdef"><b>Definition:</b> icalparser.c:141</div></div>
<div class="ttc" id="astructicalparser__impl_html"><div class="ttname"><a href="structicalparser__impl.html">icalparser_impl</a></div><div class="ttdef"><b>Definition:</b> icalparser.c:52</div></div>
</div><!-- fragment --><p>These routines will construct a parser object to which you can add lines of input and retrieve any components that the parser creates from the input. These routines work by specifying an adaptor routine to get string data from a source. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* read_stream(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size, <span class="keywordtype">void</span> *d)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fgets(s, size, (FILE*)d);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> *line;</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *component;</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser = <a class="code" href="icalparser_8h.html#a3a7a45307a9ff90ec23d632501c0bd00">icalparser_new</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// open file (first command-line argument)</span></div>
<div class="line">    FILE* stream = fopen(argv[1], <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// associate the FILE with the parser so that read_stream</span></div>
<div class="line">    <span class="comment">// will have access to it</span></div>
<div class="line">    <a class="code" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689">icalparser_set_gen_data</a>(parser, stream);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="comment">// read the file, line-by-line, and parse the data</span></div>
<div class="line">        line = <a class="code" href="icalparser_8h.html#a1e9b165c1aa2ba82605bcccadf85f74c">icalparser_get_line</a>(parser, read_stream);</div>
<div class="line">        component = <a class="code" href="icalparser_8h.html#a1138735cde70554bcdfc17dc8a595a6a">icalparser_add_line</a>(parser, line);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// if icalparser has finished parsing a component,</span></div>
<div class="line">        <span class="comment">// it will return it</span></div>
<div class="line">        <span class="keywordflow">if</span> (component != 0) {</div>
<div class="line">            <span class="comment">// print the parsed component</span></div>
<div class="line">            printf(<span class="stringliteral">&quot;%s&quot;</span>, icalcomponent_as_ical_string(component));</div>
<div class="line">            <a class="code" href="icalparser_8h.html#aa184343e374e5a201d8079df827597b2">icalparser_clean</a>(parser);</div>
<div class="line"> </div>
<div class="line">            printf(<span class="stringliteral">&quot;\n---------------\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">            icalcomponent_free(component);</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">while</span> (line != 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aicalparser_8h_html_aa184343e374e5a201d8079df827597b2"><div class="ttname"><a href="icalparser_8h.html#aa184343e374e5a201d8079df827597b2">icalparser_clean</a></div><div class="ttdeci">icalcomponent * icalparser_clean(icalparser *parser)</div><div class="ttdoc">Cleans out an icalparser and returns whatever it has parsed so far.</div><div class="ttdef"><b>Definition:</b> icalparser.c:1263</div></div>
</div><!-- fragment --><p>The parser object parameterizes the routine used to get input lines with <code><a class="el" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689" title="Sets the data that icalparser_parse will give to the line_gen_func as the parameter &#39;d&#39;.">icalparser_set_gen_data()</a></code>and <code><a class="el" href="icalparser_8h.html#a1e9b165c1aa2ba82605bcccadf85f74c" title="Given a line generator function, returns a single iCal content line.">icalparser_get_line()</a></code>. In this example, the routine <code>read_stream()</code> will fetch the next line from a stream, with the stream passed in as the <code>void*</code> parameter d. The parser calls <code>read_stream()</code> from <code><a class="el" href="icalparser_8h.html#a1e9b165c1aa2ba82605bcccadf85f74c" title="Given a line generator function, returns a single iCal content line.">icalparser_get_line()</a></code>, but it also needs to know what stream to use. This is set by the call to <code><a class="el" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689" title="Sets the data that icalparser_parse will give to the line_gen_func as the parameter &#39;d&#39;.">icalparser_set_gen_data()</a></code>. By using a different routine for <code>read_stream()</code> or passing in different data with <code><a class="el" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689" title="Sets the data that icalparser_parse will give to the line_gen_func as the parameter &#39;d&#39;.">icalparser_set_gen_data()</a></code>, you can connect to any data source.</p>
<p>Using the same mechanism, other implementations could read from memory buffers, sockets or other interfaces.</p>
<p>Since the example code is a very common way to use the parser, there is a convenience routine;</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* <a class="code" href="icalparser_8h.html#aab80e10c3636d6476bc4920ae72d4b70">icalparser_parse</a>(</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser,</div>
<div class="line">    <span class="keywordtype">char</span>* (*line_gen_func)(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size,  <span class="keywordtype">void</span>* d));</div>
<div class="ttc" id="aicalparser_8h_html_aab80e10c3636d6476bc4920ae72d4b70"><div class="ttname"><a href="icalparser_8h.html#aab80e10c3636d6476bc4920ae72d4b70">icalparser_parse</a></div><div class="ttdeci">icalcomponent * icalparser_parse(icalparser *parser, icalparser_line_gen_func line_gen_func)</div><div class="ttdoc">Message oriented parsing.</div><div class="ttdef"><b>Definition:</b> icalparser.c:642</div></div>
</div><!-- fragment --><p>To use this routine, you still must construct the parser object and pass in a reference to a line reading routine. If the parser can create a single component from the input, it will return a pointer to the newly constructed component. If the parser can construct multiple components from the input, it will return a reference to an <code>XROOT</code> component (of type <code>ICAL_XROOT_COMPONENT</code>.) This <code>XROOT</code> component will hold all of the components constructed from the input as children.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* read_stream(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> size, <span class="keywordtype">void</span> *d)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fgets(s, size, (FILE*)d);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span>* line;</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *component;</div>
<div class="line">    <a class="code" href="structicalparser__impl.html">icalparser</a> *parser = <a class="code" href="icalparser_8h.html#a3a7a45307a9ff90ec23d632501c0bd00">icalparser_new</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// open file (first command-line argument)</span></div>
<div class="line">    FILE* stream = fopen(argv[1], <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// associate the FILE with the parser so that read_stream</span></div>
<div class="line">    <span class="comment">// will have access to it</span></div>
<div class="line">    <a class="code" href="icalparser_8h.html#aae6d08b4084610e225621a25dddd7689">icalparser_set_gen_data</a>(parser, stream);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// parse the opened file</span></div>
<div class="line">    component = <a class="code" href="icalparser_8h.html#aab80e10c3636d6476bc4920ae72d4b70">icalparser_parse</a>(parser, read_stream);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (component != 0) {</div>
<div class="line">        <span class="comment">// print the parsed component</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;%s&quot;</span>, icalcomponent_as_ical_string(component));</div>
<div class="line">        icalcomponent_free(component);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="icalparser_8h.html#a1cb8b8678b781d3d2ede0fbce613b90d">icalparser_free</a>(parser);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md111"></a>
5.2 Accessing Components</h2>
<p>Given a reference to a component, you probably will want to access the properties, parameters and values inside. Libical interfaces let you find sub-component, add and remove sub-components, and do the same three operations on properties.</p>
<h3><a class="anchor" id="autotoc_md112"></a>
5.2.1 Finding Components</h3>
<p>To find a sub-component of a component, use:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalcomponent_get_first_component(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalcomponent_kind kind);</div>
</div><!-- fragment --><p>This routine will return a reference to the first component of the type <code>kind</code>. The key kind values, listed in <a class="el" href="icalenums_8h.html">icalenums.h</a> are:</p>
<ul>
<li><code>ICAL_ANY_COMPONENT</code></li>
<li><code>ICAL_VEVENT_COMPONENT</code></li>
<li><code>ICAL_VTODO_COMPONENT</code></li>
<li><code>ICAL_VJOURNAL_COMPONENT</code></li>
<li><code>ICAL_VCALENDAR_COMPONENT</code></li>
<li><code>ICAL_VFREEBUSY_COMPONENT</code></li>
<li><code>ICAL_VALARM_COMPONENT</code></li>
</ul>
<p>These are only the most common components; there are many more listed in <a class="el" href="icalenums_8h.html">icalenums.h</a>.</p>
<p>As you might guess, if there is more than one subcomponent of the type you have chosen, this routine will return only the first. to get at the others, you need to iterate through the component.</p>
<h3><a class="anchor" id="autotoc_md113"></a>
5.2.2 Iterating Through Components</h3>
<p>Iteration requires a second routine to get the next subcomponent after the first:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalcomponent_get_next_component(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalcomponent_kind kind);</div>
</div><!-- fragment --><p>With the 'first' and 'next' routines, you can create a for loop to iterate through all of a components subcomponents</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *c;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(c = icalcomponent_get_first_component(comp, ICAL_ANY_COMPONENT);</div>
<div class="line">    c != 0;</div>
<div class="line">    c = icalcomponent_get_next_component(comp, ICAL_ANY_COMPONENT))</div>
<div class="line">{</div>
<div class="line">      do_something(c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code bit will iterate through all of the subcomponents in <code>comp</code> but you can select a specific type of component by changing <code>ICAL_ANY_COMPONENT</code> to another component type.</p>
<h3><a class="anchor" id="autotoc_md114"></a>
5.2.3 Using Component Iterators</h3>
<p>The iteration model in the previous section requires the component to keep the state of the iteration. So, you could not use this model to perform a sorting operations, since you'd need two iterators and there is only space for one. If you ever call <code>icalcomponent_get_first_component()</code> when an iteration is in progress, the pointer will be reset to the beginning.</p>
<p>To solve this problem, there are also external iterators for components. The routines associated with these external iterators are:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcompiter.html">icalcompiter</a> icalcomponent_begin_component(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalcomponent_kind kind);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcompiter.html">icalcompiter</a> icalcomponent_end_component(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalcomponent_kind kind);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalcompiter_next(</div>
<div class="line">    <a class="code" href="structicalcompiter.html">icalcompiter</a>* i);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalcompiter_prior(</div>
<div class="line">    <a class="code" href="structicalcompiter.html">icalcompiter</a>* i);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalcompiter_deref(</div>
<div class="line">    <a class="code" href="structicalcompiter.html">icalcompiter</a>* i);</div>
<div class="ttc" id="astructicalcompiter_html"><div class="ttname"><a href="structicalcompiter.html">icalcompiter</a></div><div class="ttdef"><b>Definition:</b> icalcomponent.h:37</div></div>
</div><!-- fragment --><p>The <code>*_begin_*()</code> and <code>*_end_*()</code> routines return a new iterator that points to the beginning and end of the list of subcomponent for the given component, and the kind argument works like the kind argument for internal iterators.</p>
<p>After creating an iterators, use <code>*_next()</code> and <code>*_prior()</code> to step forward and backward through the list and get the component that the iterator points to, and use <code>_deref()</code> to return the component that the iterator points to without moving the iterator. All routines will return 0 when they move to point off the end of the list.</p>
<p>Here is an example of a loop using these routines:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i = icalcomponent_begin_component(impl-&gt;cluster, ICAL_ANY_COMPONENT);</div>
<div class="line">    icalcompiter_deref(&amp;i)!= 0;</div>
<div class="line">    icalcompiter_next(&amp;i)) </div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *<span class="keyword">this</span> = icalcompiter_deref(&amp;i);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md115"></a>
5.2.4 Removing Components</h3>
<p>Removing an element from a list while iterating through the list with the internal iterators can cause problems, since you will probably be removing the element that the internal iterator points to. The <code>_remove()</code> routine will keep the iterator valid by moving it to the next component, but in a normal loop, this will result in two advances per iteration, and you will remove only every other component. To avoid the problem, you will need to step the iterator ahead of the element you are going to remove, like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(c = icalcomponent_get_first_component(parent_comp, ICAL_ANY_COMPONENT);</div>
<div class="line">    c != 0;</div>
<div class="line">    c = next)</div>
<div class="line">{</div>
<div class="line">    next = icalcomponent_get_next_component(parent_comp, ICAL_ANY_COMPONENT);</div>
<div class="line">    icalcomponent_remove_component(parent_comp,c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another way to remove components is to rely on the side effect of <code>icalcomponent_remove_component()</code>: if component iterator in the parent component is pointing to the child that will be removed, it will move the iterator to the component after the child. The following code will exploit this behavior:</p>
<div class="fragment"><div class="line">icalcomponent_get_first_component(parent_comp,ICAL_VEVENT_COMPONENT);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>((c=icalcomponent_get_current_component(c)) != 0){</div>
<div class="line">   <span class="keywordflow">if</span>(icalcomponent_isa(c) == ICAL_VEVENT_COMPONENT){</div>
<div class="line">      icalcomponent_remove_component(parent_comp,inner);</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      icalcomponent_get_next_component(parent_comp,ICAL_VEVENT_COMPONENT);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md116"></a>
5.2.5 Working with properties and parameters</h3>
<p>Finding, iterating and removing properties works the same as it does for components, using the property-specific or parameter-specific interfaces:</p>
<div class="fragment"><div class="line">icalproperty* icalcomponent_get_first_property(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalproperty_kind kind);</div>
<div class="line"> </div>
<div class="line">icalproperty* icalcomponent_get_next_property(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalproperty_kind kind);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalcomponent_add_property(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalproperty* property);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalcomponent_remove_property(</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component,</div>
<div class="line">    icalproperty* property);</div>
</div><!-- fragment --><p>For parameters:</p>
<div class="fragment"><div class="line">icalparameter* icalproperty_get_first_parameter(</div>
<div class="line">     icalproperty* prop,</div>
<div class="line">     icalparameter_kind kind);</div>
<div class="line"> </div>
<div class="line">icalparameter* icalproperty_get_next_parameter(</div>
<div class="line">     icalproperty* prop,</div>
<div class="line">     icalparameter_kind kind);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalproperty_add_parameter(</div>
<div class="line">     icalproperty* prop,</div>
<div class="line">     icalparameter* parameter);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="icalproperty_8h.html#a68baed35b3b1af4ababf2c62b2ced68d">icalproperty_remove_parameter_by_kind</a>(</div>
<div class="line">     icalproperty* prop,</div>
<div class="line">     icalparameter_kind kind);</div>
<div class="ttc" id="aicalproperty_8h_html_a68baed35b3b1af4ababf2c62b2ced68d"><div class="ttname"><a href="icalproperty_8h.html#a68baed35b3b1af4ababf2c62b2ced68d">icalproperty_remove_parameter_by_kind</a></div><div class="ttdeci">void icalproperty_remove_parameter_by_kind(icalproperty *prop, icalparameter_kind kind)</div><div class="ttdoc">Removes all parameters with the specified kind.</div><div class="ttdef"><b>Definition:</b> icalproperty.c:633</div></div>
</div><!-- fragment --><p>Note that since there should be only one parameter of each type in a property, you will rarely need to use <code>icalparameter_get_next_parameter()</code>.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
5.2.6 Working with values</h3>
<p>Values are typically part of a property, although they can exist on their own. You can manipulate them either as part of the property or independently.</p>
<p>The most common way to work with values to is to manipulate them from the properties that contain them. This involves fewer routine calls and intermediate variables than working with them independently, and it is type-safe.</p>
<p>For each property, there are a <code>_get_()</code> and a <code>_set_()</code> routine that accesses the internal value. For instanace, for the <code>UID</code> property, the routines are:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> icalproperty_set_uid(</div>
<div class="line">    icalproperty* prop, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* icalproperty_get_uid(</div>
<div class="line">    icalproperty* prop);</div>
</div><!-- fragment --><p>For multi-valued properties, like <code>ATTACH</code>, the value type is usually a struct or union that holds both possible types.</p>
<p>If you want to work with the underlying value object, you can get and set it with:</p>
<div class="fragment"><div class="line">icalvalue* icalproperty_get_value(</div>
<div class="line">    icalproperty* prop);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalproperty_set_value(</div>
<div class="line">    icalproperty* prop, </div>
<div class="line">    icalvalue* value);</div>
</div><!-- fragment --><p><code>icalproperty_get_value()</code> will return a reference that you can manipulate with other icalvalue routines. Most of the time, you will have to know what the type of the value is. For instance, if you know that the value is a <code>DATETIME</code> type, you can manipulate it with:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> icalvalue_get_datetime(</div>
<div class="line">    icalvalue* value);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalvalue_set_datetime(</div>
<div class="line">    icalvalue* value, </div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> v);</div>
</div><!-- fragment --><p>When working with an extension property or value (and <code>X-PROPERTY</code> or a property that has the parameter <code>VALUE=x-name</code>), the value type is always a string. To get and set the value, use:</p>
<div class="fragment"><div class="line">void icalproperty_set_x(</div>
<div class="line">    icalproperty* prop, </div>
<div class="line">    char* v);</div>
<div class="line"> </div>
<div class="line">char* icalproperty_get_x(</div>
<div class="line">    icalproperty* prop);</div>
</div><!-- fragment --><p>All X properties have the type of <code>ICAL_X_PROPERTY</code>, so you will need these routines to get and set the name of the property:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* icalproperty_get_x_name(</div>
<div class="line">    icalproperty* prop)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icalproperty_set_x_name(</div>
<div class="line">    icalproperty* prop, </div>
<div class="line">    <span class="keywordtype">char</span>* name);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md118"></a>
5.2.7 Checking Component Validity</h3>
<p><a href="https://tools.ietf.org/html/rfc5546">RFC5546</a> defines rules for what properties must exist in a component to be used for transferring scheduling data. Most of these rules relate to the existence of properties relative to the <code>METHOD</code> property, which declares what operation a remote receiver should use to process a component. For instance, if the <code>METHOD</code> is <code>REQUEST</code> and the component is a <code>VEVENT</code>, the sender is probably asking the receiver to join in a meeting. In this case, RFC5546 says that the component must specify a start time (<code>DTSTART</code>) and list the receiver as an attendee (<code>ATTENDEE</code>).</p>
<p>Libical can check these restrictions with the routine:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57">icalrestriction_check</a>(<a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* comp);</div>
<div class="ttc" id="aicalrestriction_8h_html_a36eeedfdce2344da44fd09d9e3f18b57"><div class="ttname"><a href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57">icalrestriction_check</a></div><div class="ttdeci">int icalrestriction_check(icalcomponent *comp)</div><div class="ttdoc">Checks if a given VCALENDAR meets all the restrictions imposed by the standard.</div></div>
</div><!-- fragment --><p>This routine returns 0 if the component does not pass RFC5546 restrictions, or if the component is malformed. The component you pass in must be a <code>VCALENDAR</code>, with one or more children, like the examples in RFC5546.</p>
<p>When this routine runs, it will insert new properties into the component to indicate any errors it finds. See section 6.5.3, <code>X-LIC-ERROR</code> for more information about these error properties.</p>
<p>5.2.8 Converting Components to Text</p>
<p>To create an RFC5545 compliant text representation of an object, use one of the <code>*_as_ical_string()</code> routines:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* icalcomponent_as_ical_string(<a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* component)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span>* icalproperty_as_ical_string(icalproperty* property)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span>* <a class="code" href="icalparameter_8h.html#adca99971f21bcb7259f54c524837003e">icalparameter_as_ical_string</a>(icalparameter* parameter)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span>* icalvalue_as_ical_string(icalvalue* value)</div>
<div class="ttc" id="aicalparameter_8h_html_adca99971f21bcb7259f54c524837003e"><div class="ttname"><a href="icalparameter_8h.html#adca99971f21bcb7259f54c524837003e">icalparameter_as_ical_string</a></div><div class="ttdeci">char * icalparameter_as_ical_string(icalparameter *parameter)</div><div class="ttdoc">Converts ::icalparameter into a string representation.</div><div class="ttdef"><b>Definition:</b> icalparameter.c:173</div></div>
</div><!-- fragment --><p>In most cases, you will only use <code>icalcomponent_as_ical_string()</code>, since it will cascade and convert all of the parameters, properties and values that are attached to the root component.</p>
<p>Remember that the string returned by these routines is owned by the library, and will eventually be re-written. You should copy it if you want to preserve it.</p>
<h2><a class="anchor" id="autotoc_md119"></a>
5.3 Time</h2>
<h3><a class="anchor" id="autotoc_md120"></a>
5.3.1 Time structure</h3>
<p>Libical defines its own time structure for storing all dates and times. It would have been nice to re-use the C library's struct <code>tm</code>, but that structure does not differentiate between dates and times, and between local time and UTC. The libical structure is:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">year</a>;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#abfb15dfde907211cafd3cd6cafa5531d">month</a>;</div>
<div class="line">  <span class="keywordtype">int</span> day;</div>
<div class="line">  <span class="keywordtype">int</span> hour;</div>
<div class="line">  <span class="keywordtype">int</span> minute;</div>
<div class="line">  <span class="keywordtype">int</span> second;</div>
<div class="line">  <span class="keywordtype">int</span> is_utc; <span class="comment">/* 1-&gt; time is in UTC timezone */</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#a48d5ac850b2675cd80bbcefe00d7ae96">is_date</a>; <span class="comment">/* 1 -&gt; interpret this as date. */</span> </div>
<div class="line">};</div>
<div class="ttc" id="astructicaltimetype_html_a48d5ac850b2675cd80bbcefe00d7ae96"><div class="ttname"><a href="structicaltimetype.html#a48d5ac850b2675cd80bbcefe00d7ae96">icaltimetype::is_date</a></div><div class="ttdeci">int is_date</div><div class="ttdef"><b>Definition:</b> icaltime.h:113</div></div>
<div class="ttc" id="astructicaltimetype_html_a4f64cd87ff0d4aba7bf318485b7374b8"><div class="ttname"><a href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">icaltimetype::year</a></div><div class="ttdeci">int year</div><div class="ttdef"><b>Definition:</b> icaltime.h:106</div></div>
<div class="ttc" id="astructicaltimetype_html_abfb15dfde907211cafd3cd6cafa5531d"><div class="ttname"><a href="structicaltimetype.html#abfb15dfde907211cafd3cd6cafa5531d">icaltimetype::month</a></div><div class="ttdeci">int month</div><div class="ttdef"><b>Definition:</b> icaltime.h:107</div></div>
</div><!-- fragment --><p>The <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> fields hold the broken-out time values. The <code>is_utc</code> field distinguishes between times in UTC and a local time zone. The <code>is_date</code> field indicates if the time should be interpreted only as a date. If it is a date, the hour, minute and second fields are assumed to be zero, regardless of their actual values.</p>
<h3><a class="anchor" id="autotoc_md121"></a>
5.3.2 Creating time structures</h3>
<p>There are several ways to create a new icaltimetype structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5">icaltime_from_string</a>(</div>
<div class="line">    const char* str);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#a86a8cb717a14ef07e75060e22711d401">icaltime_from_timet_with_zone</a>(</div>
<div class="line">    time_t v,</div>
<div class="line">    int <a class="code" href="structicaltimetype.html#a48d5ac850b2675cd80bbcefe00d7ae96">is_date</a>,</div>
<div class="line">    <a class="code" href="struct__icaltimezone.html">icaltimezone</a>* <a class="code" href="structicaltimetype.html#aa60ce5ca11223d8d34702962fc7ac57c">zone</a>);</div>
<div class="ttc" id="aicaltime_8h_html_a1b66b9f52a9823b95e4cd33f9dd9b8e5"><div class="ttname"><a href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5">icaltime_from_string</a></div><div class="ttdeci">struct icaltimetype icaltime_from_string(const char *str)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icaltime.c:339</div></div>
<div class="ttc" id="aicaltime_8h_html_a86a8cb717a14ef07e75060e22711d401"><div class="ttname"><a href="icaltime_8h.html#a86a8cb717a14ef07e75060e22711d401">icaltime_from_timet_with_zone</a></div><div class="ttdeci">struct icaltimetype icaltime_from_timet_with_zone(const time_t tm, const int is_date, const icaltimezone *zone)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icaltime.c:183</div></div>
<div class="ttc" id="astruct__icaltimezone_html"><div class="ttname"><a href="struct__icaltimezone.html">_icaltimezone</a></div><div class="ttdef"><b>Definition:</b> icaltimezoneimpl.h:23</div></div>
<div class="ttc" id="astructicaltimetype_html_aa60ce5ca11223d8d34702962fc7ac57c"><div class="ttname"><a href="structicaltimetype.html#aa60ce5ca11223d8d34702962fc7ac57c">icaltimetype::zone</a></div><div class="ttdeci">const icaltimezone * zone</div><div class="ttdef"><b>Definition:</b> icaltime.h:117</div></div>
</div><!-- fragment --><p><code><a class="el" href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5" title="Constructor.">icaltime_from_string()</a></code> takes any RFC5545 compliant time string:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> tt = <a class="code" href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5">icaltime_from_string</a>(<span class="stringliteral">&quot;19970101T103000&quot;</span>);</div>
</div><!-- fragment --><p><code><a class="el" href="icaltime_8h.html#a86a8cb717a14ef07e75060e22711d401" title="Constructor.">icaltime_from_timet_with_zone()</a></code> takes a <code>time_t</code> value, representing seconds past the POSIX epoch, a flag to indicate if the time is a date, and a time zone. Dates have an identical structure to a time, but the time portion (hours, minutes and seconds) is always 00:00:00. Dates act differently in sorting and comparison, and they have a different string representation in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a>.</p>
<h3><a class="anchor" id="autotoc_md122"></a>
5.3.3 Time manipulating routines</h3>
<p>The <code>null</code> time value is used to indicate that the data in the structure is not a valid time.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#af3f088ebb60b8716131742ef16eb7ce1">icaltime_null_time</a>(void);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="icaltime_8h.html#a97483d9daf2fc8f8b1bbdc0c75ced095">icaltime_is_null_time</a>(<span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> t);</div>
<div class="ttc" id="aicaltime_8h_html_a97483d9daf2fc8f8b1bbdc0c75ced095"><div class="ttname"><a href="icaltime_8h.html#a97483d9daf2fc8f8b1bbdc0c75ced095">icaltime_is_null_time</a></div><div class="ttdeci">int icaltime_is_null_time(const struct icaltimetype t)</div><div class="ttdoc">Returns true if the time is null.</div><div class="ttdef"><b>Definition:</b> icaltime.c:600</div></div>
<div class="ttc" id="aicaltime_8h_html_af3f088ebb60b8716131742ef16eb7ce1"><div class="ttname"><a href="icaltime_8h.html#af3f088ebb60b8716131742ef16eb7ce1">icaltime_null_time</a></div><div class="ttdeci">struct icaltimetype icaltime_null_time(void)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icaltime.c:553</div></div>
</div><!-- fragment --><p>It is sensible for the broken-out time fields to contain values that are not permitted in an ISO compliant time string. For instance, the seconds field can hold values greater than 59, and the hours field can hold values larger than 24. The excessive values will be rolled over into the next larger field when the structure is normalized.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#aade16ce1ff855029a77965927b5f66fd">icaltime_normalize</a>(struct <a class="code" href="structicaltimetype.html">icaltimetype</a> t);</div>
<div class="ttc" id="aicaltime_8h_html_aade16ce1ff855029a77965927b5f66fd"><div class="ttname"><a href="icaltime_8h.html#aade16ce1ff855029a77965927b5f66fd">icaltime_normalize</a></div><div class="ttdeci">struct icaltimetype icaltime_normalize(const struct icaltimetype t)</div><div class="ttdoc">Normalizes the icaltime, so all of the time components are in their normal ranges.</div><div class="ttdef"><b>Definition:</b> icaltime.c:331</div></div>
</div><!-- fragment --><p>Normalizing allows you to do arithmetic operations on time values.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> tt = <a class="code" href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5">icaltime_from_string</a>(<span class="stringliteral">&quot;19970101T103000&quot;</span>);</div>
<div class="line"> </div>
<div class="line">tt.days +=3</div>
<div class="line">tt.second += 70;</div>
<div class="line"> </div>
<div class="line">tt = <a class="code" href="icaltime_8h.html#aade16ce1ff855029a77965927b5f66fd">icaltime_normalize</a>(tt);</div>
</div><!-- fragment --><p>There are several routines to get the day of the week or month, etc, from a time structure.</p>
<div class="fragment"><div class="line"><span class="keywordtype">short</span> <a class="code" href="icaltime_8h.html#a39606ca412bb507284a55356c9522b91">icaltime_day_of_year</a>(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> t);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#a2915233b392cc2a68aa5a9acf39e2307">icaltime_from_day_of_year</a>(</div>
<div class="line">    short doy, </div>
<div class="line">    short <a class="code" href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">year</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">short</span> <a class="code" href="icaltime_8h.html#a6df493d8d79b6eef9fca25adefbb6d69">icaltime_day_of_week</a>(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> t);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">short</span> <a class="code" href="icaltime_8h.html#a3e4ae35fd30b3d2b829f0e5bb7328e31">icaltime_start_doy_week</a>(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> t, </div>
<div class="line">    <span class="keywordtype">int</span> fdow);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">short</span> <a class="code" href="icaltime_8h.html#a5be09f07b9444f73a66d179ae61f137a">icaltime_week_number</a>(</div>
<div class="line">    <span class="keywordtype">short</span> day_of_month, </div>
<div class="line">    <span class="keywordtype">short</span> <a class="code" href="structicaltimetype.html#abfb15dfde907211cafd3cd6cafa5531d">month</a>, </div>
<div class="line">    <span class="keywordtype">short</span> <a class="code" href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">year</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">short</span> <a class="code" href="icaltime_8h.html#a99e9d9e26bea0231d23eb171990a1e8f">icaltime_days_in_month</a>(</div>
<div class="line">    <span class="keywordtype">short</span> <a class="code" href="structicaltimetype.html#abfb15dfde907211cafd3cd6cafa5531d">month</a>,</div>
<div class="line">    <span class="keywordtype">short</span> <a class="code" href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">year</a>);</div>
<div class="ttc" id="aicaltime_8h_html_a2915233b392cc2a68aa5a9acf39e2307"><div class="ttname"><a href="icaltime_8h.html#a2915233b392cc2a68aa5a9acf39e2307">icaltime_from_day_of_year</a></div><div class="ttdeci">struct icaltimetype icaltime_from_day_of_year(const int doy, const int year)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> icaltime.c:518</div></div>
<div class="ttc" id="aicaltime_8h_html_a39606ca412bb507284a55356c9522b91"><div class="ttname"><a href="icaltime_8h.html#a39606ca412bb507284a55356c9522b91">icaltime_day_of_year</a></div><div class="ttdeci">int icaltime_day_of_year(const struct icaltimetype t)</div><div class="ttdoc">Returns the day of the year, counting from 1 (Jan 1st).</div><div class="ttdef"><b>Definition:</b> icaltime.c:511</div></div>
<div class="ttc" id="aicaltime_8h_html_a3e4ae35fd30b3d2b829f0e5bb7328e31"><div class="ttname"><a href="icaltime_8h.html#a3e4ae35fd30b3d2b829f0e5bb7328e31">icaltime_start_doy_week</a></div><div class="ttdeci">int icaltime_start_doy_week(const struct icaltimetype t, int fdow)</div><div class="ttdoc">Returns the day of the year for the first day of the week that the given time is within.</div><div class="ttdef"><b>Definition:</b> icaltime.c:474</div></div>
<div class="ttc" id="aicaltime_8h_html_a5be09f07b9444f73a66d179ae61f137a"><div class="ttname"><a href="icaltime_8h.html#a5be09f07b9444f73a66d179ae61f137a">icaltime_week_number</a></div><div class="ttdeci">int icaltime_week_number(const struct icaltimetype t)</div><div class="ttdoc">Returns the week number for the week the given time is within.</div><div class="ttdef"><b>Definition:</b> icaltime.c:495</div></div>
<div class="ttc" id="aicaltime_8h_html_a6df493d8d79b6eef9fca25adefbb6d69"><div class="ttname"><a href="icaltime_8h.html#a6df493d8d79b6eef9fca25adefbb6d69">icaltime_day_of_week</a></div><div class="ttdeci">int icaltime_day_of_week(const struct icaltimetype t)</div><div class="ttdoc">Returns the day of the week of the given time.</div><div class="ttdef"><b>Definition:</b> icaltime.c:459</div></div>
<div class="ttc" id="aicaltime_8h_html_a99e9d9e26bea0231d23eb171990a1e8f"><div class="ttname"><a href="icaltime_8h.html#a99e9d9e26bea0231d23eb171990a1e8f">icaltime_days_in_month</a></div><div class="ttdeci">int icaltime_days_in_month(const int month, const int year)</div><div class="ttdef"><b>Definition:</b> icaltime.c:435</div></div>
</div><!-- fragment --><p>Two routines convert time structures to and from the number of seconds since the POSIX epoch. The <code>is_date</code> field indicates whether or not the hour, minute and second fields should be used in the conversion.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> <a class="code" href="icaltime_8h.html#a86a8cb717a14ef07e75060e22711d401">icaltime_from_timet_with_zone</a>(</div>
<div class="line">    time_t v,</div>
<div class="line">    int <a class="code" href="structicaltimetype.html#a48d5ac850b2675cd80bbcefe00d7ae96">is_date</a>,</div>
<div class="line">    <a class="code" href="struct__icaltimezone.html">icaltimezone</a>* <a class="code" href="structicaltimetype.html#aa60ce5ca11223d8d34702962fc7ac57c">zone</a>);</div>
<div class="line"> </div>
<div class="line">time_t <a class="code" href="icaltime_8h.html#a7b39742d0f786f41df391c62ee56ec10">icaltime_as_timet</a>(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a>);</div>
<div class="ttc" id="aicaltime_8h_html_a7b39742d0f786f41df391c62ee56ec10"><div class="ttname"><a href="icaltime_8h.html#a7b39742d0f786f41df391c62ee56ec10">icaltime_as_timet</a></div><div class="ttdeci">time_t icaltime_as_timet(const struct icaltimetype)</div><div class="ttdef"><b>Definition:</b> icaltime.c:231</div></div>
</div><!-- fragment --><p>The compare routine works exactly like <code>strcmp()</code>, but on time structures.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="icaltime_8h.html#a123759194c6e8c44e1b05193cb61196a">icaltime_compare</a>(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> a, </div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> b);</div>
<div class="ttc" id="aicaltime_8h_html_a123759194c6e8c44e1b05193cb61196a"><div class="ttname"><a href="icaltime_8h.html#a123759194c6e8c44e1b05193cb61196a">icaltime_compare</a></div><div class="ttdeci">int icaltime_compare(const struct icaltimetype a, const struct icaltimetype b)</div><div class="ttdoc">Returns -1, 0, or 1 to indicate that a is less than b, a equals b, or a is greater than b.</div><div class="ttdef"><b>Definition:</b> icaltime.c:609</div></div>
</div><!-- fragment --><p>The following routines convert between UTC and a named timezone. The tzid field must be a timezone name from the Olsen database, such as <code>America/Los_Angeles</code>.</p>
<p>The <code>utc_offset</code> routine returns the offset of the named time zone from UTC, in seconds.</p>
<p>The <code>tt</code> parameter in the following routines indicates the date on which the conversion should be made. The parameter is necessary because timezones have many different rules for when daylight savings time is used, and these rules can change over time. So, for a single timezone one year may have daylight savings time on March 15, but for other years March 15 may be standard time, and some years may have standard time all year.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> icaltime_utc_offset(</div>
<div class="line">    <span class="keyword">struct</span> <a class="code" href="structicaltimetype.html">icaltimetype</a> tt, </div>
<div class="line">    <span class="keywordtype">char</span>* tzid);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> icaltime_local_utc_offset();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> icaltime_as_utc(</div>
<div class="line">    struct <a class="code" href="structicaltimetype.html">icaltimetype</a> tt, </div>
<div class="line">    char* tzid);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> icaltime_as_zone(</div>
<div class="line">    struct <a class="code" href="structicaltimetype.html">icaltimetype</a> tt, </div>
<div class="line">    char* tzid);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> icaltime_as_local(</div>
<div class="line">    struct <a class="code" href="structicaltimetype.html">icaltimetype</a> tt);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md123"></a>
5.4 Storing Objects</h2>
<p>The libical distribution includes a separate library, libicalss, that allows you to store iCal component data to disk in a variety of ways.</p>
<p>The file storage routines are organized in an inheritance hierarchy that is rooted in icalset, with the derived class icalfileset and icaldirset. Icalfileset stores components to a file, while icaldirset stores components to multiple files, one per month based on DTSTAMP. Other storages classes, for storage to a heap or a mysql database for example, could be added in the future.</p>
<p>All of the icalset derived classes have the same interface:</p>
<div class="fragment"><div class="line"><a class="code" href="structicaldirset__impl.html">icaldirset</a>* icaldirset_new(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icaldirset_free(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* icaldirset_path(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icaldirset_mark(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icaldirset_commit(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> <a class="code" href="icaldirset_8h.html#a123ff2d1b0887caafc027936bc9b921b">icaldirset_add_component</a>(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* comp);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> <a class="code" href="icaldirset_8h.html#ae3b06ab0380ffb7c0e4b7ce9251931ad">icaldirset_remove_component</a>(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* comp);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> icaldirset_count_components(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    icalcomponent_kind kind);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icaldirset_select(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* gauge);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> icaldirset_clear(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icaldirset_fetch(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* uid);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> icaldirset_has_uid(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* uid);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icaldirset_fetch_match(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* set, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *c);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icaldirset_modify(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *oldc,</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *newc);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icaldirset_get_current_component(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icaldirset_get_first_component(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icaldirset_get_next_component(</div>
<div class="line">    <a class="code" href="structicaldirset__impl.html">icaldirset</a>* store);</div>
<div class="ttc" id="aicaldirset_8h_html_a123ff2d1b0887caafc027936bc9b921b"><div class="ttname"><a href="icaldirset_8h.html#a123ff2d1b0887caafc027936bc9b921b">icaldirset_add_component</a></div><div class="ttdeci">icalerrorenum icaldirset_add_component(icalset *store, icalcomponent *comp)</div><div class="ttdef"><b>Definition:</b> icaldirset.c:297</div></div>
<div class="ttc" id="aicaldirset_8h_html_ae3b06ab0380ffb7c0e4b7ce9251931ad"><div class="ttname"><a href="icaldirset_8h.html#ae3b06ab0380ffb7c0e4b7ce9251931ad">icaldirset_remove_component</a></div><div class="ttdeci">icalerrorenum icaldirset_remove_component(icalset *store, icalcomponent *comp)</div><div class="ttdef"><b>Definition:</b> icaldirset.c:384</div></div>
<div class="ttc" id="aicalerror_8h_html_a601c122fcea522513b1b7732fa23e833"><div class="ttname"><a href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a></div><div class="ttdeci">icalerrorenum</div><div class="ttdoc">Represents the different types of errors that can be triggered in libical.</div><div class="ttdef"><b>Definition:</b> icalerror.h:76</div></div>
<div class="ttc" id="astructicaldirset__impl_html"><div class="ttname"><a href="structicaldirset__impl.html">icaldirset_impl</a></div><div class="ttdef"><b>Definition:</b> icaldirsetimpl.h:31</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md124"></a>
5.4.1 Creating a new set</h3>
<p>You can create a new set from either the base class or the direved class. From the base class use one of:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalset__impl.html">icalset</a>* icalset_new_file(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalset__impl.html">icalset</a>* icalset_new_dir(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalset__impl.html">icalset</a>* icalset_new_heap(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalset__impl.html">icalset</a>* icalset_new_mysql(<span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="ttc" id="astructicalset__impl_html"><div class="ttname"><a href="structicalset__impl.html">icalset_impl</a></div><div class="ttdef"><b>Definition:</b> icalset.h:61</div></div>
</div><!-- fragment --><p>You can also create a new set based on the derived class, For instance, with icalfileset:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalfileset__impl.html">icalfileset</a>* icalfileset_new(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalfileset__impl.html">icalfileset</a>* icalfileset_new_open(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path, </div>
<div class="line">    <span class="keywordtype">int</span> flags, </div>
<div class="line">    <span class="keywordtype">int</span> mode);</div>
<div class="ttc" id="astructicalfileset__impl_html"><div class="ttname"><a href="structicalfileset__impl.html">icalfileset_impl</a></div><div class="ttdef"><b>Definition:</b> icalfilesetimpl.h:28</div></div>
</div><!-- fragment --><p><code>icalset_new_file()</code> is identical to <code>icalfileset_new()</code>. Both routines will open an existing file for reading and writing, or create a new file if it does not exist. <code>icalfileset_new_open()</code> takes the same arguments as the open() system routine and behaves in the same way.</p>
<p>The icalset and icalfileset objects are somewhat interchangeable &ndash; you can use an <code>icalfileset*</code> as an argument to any of the icalset routines.</p>
<p>The following examples will all use icalfileset routines; using the other icalset derived classes will be similar.</p>
<h3><a class="anchor" id="autotoc_md125"></a>
5.4.2 Adding, Finding and Removing Components</h3>
<p>To add components to a set, use:</p>
<div class="fragment"><div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icalfileset_add_component(</div>
<div class="line">    <a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster, </div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* child);</div>
</div><!-- fragment --><p>The fileset keeps an in-memory copy of the components, and this set must be written back to the file occasionally. There are two routines to manage this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> icalfileset_mark(<a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icalfileset_commit(<a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster);</div>
</div><!-- fragment --><p><code>icalfileset_mark()</code> indicates that the in-memory components have changed. Calling the <code>_add_component()</code> routine will call <code>_mark()</code> automatically, but you may need to call it yourself if you have made a change to an existing component. The <code>_commit()</code> routine writes the data base to disk, but only if it is marked. The <code>_commit()</code> routine is called automatically when the icalfileset is freed.</p>
<p>To iterate through the components in a set, use:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalfileset_get_first_component(<a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalfileset_get_next_component(<a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structicalcomponent__impl.html">icalcomponent</a>* icalfileset_get_current_component (<a class="code" href="structicalfileset__impl.html">icalfileset</a>* cluster);</div>
</div><!-- fragment --><p>These routines work like the corresponding routines from icalcomponent, except that their output is filtered through a gauge. A gauge is a test for the properties within a components; only components that pass the test are returned. A gauge can be constructed from a MINSQL string with:</p>
<div class="fragment"><div class="line"><a class="code" href="structicalgauge__impl.html">icalgauge</a>* icalgauge_new_from_sql(<span class="keyword">const</span> <span class="keywordtype">char</span>* sql);</div>
<div class="ttc" id="astructicalgauge__impl_html"><div class="ttname"><a href="structicalgauge__impl.html">icalgauge_impl</a></div><div class="ttdef"><b>Definition:</b> icalgaugeimpl.h:55</div></div>
</div><!-- fragment --><p>Then, you can add the gauge to the set with :</p>
<div class="fragment"><div class="line"><a class="code" href="icalerror_8h.html#a601c122fcea522513b1b7732fa23e833">icalerrorenum</a> icalfileset_select(</div>
<div class="line">    <a class="code" href="structicalfileset__impl.html">icalfileset</a>* store, </div>
<div class="line">    <a class="code" href="structicalgauge__impl.html">icalgauge</a>* gauge);</div>
</div><!-- fragment --><p>Here is an example that puts all of these routines together:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_fileset()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structicalfileset__impl.html">icalfileset</a> *fs;</div>
<div class="line">    <a class="code" href="structicalcomponent__impl.html">icalcomponent</a> *c;</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordtype">char</span> *path = <span class="stringliteral">&quot;test_fileset.ics&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structicalgauge__impl.html">icalgauge</a>  *g = icalgauge_new_from_sql(</div>
<div class="line">        <span class="stringliteral">&quot;SELECT * FROM VEVENT WHERE DTSTART &gt; &#39;20000103T120000Z&#39; AND</span></div>
<div class="line"><span class="stringliteral">DTSTART &lt;= &#39;20000106T120000Z&#39;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    fs = icalfileset_new(path);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i!= 10; i++){</div>
<div class="line">        c = make_component(i); <span class="comment">/* Make a new component where DTSTART</span></div>
<div class="line"><span class="comment">has month of i */</span></div>
<div class="line">        icalfileset_add_component(fs,c);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    icalfileset_commit(fs); <span class="comment">/* Write to disk */</span></div>
<div class="line">    icalfileset_select(fs,g); <span class="comment">/* Set the gauge to filter components */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (c = icalfileset_get_first_component(fs);</div>
<div class="line">         c != 0;</div>
<div class="line">         c = icalfileset_get_next_component(fs))</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a> t = <a class="code" href="icalcomponent_8h.html#a23e20161c54d3aeff51e1cc444eee063">icalcomponent_get_dtstart</a>(c);</div>
<div class="line">        printf(<span class="stringliteral">&quot;%s\n&quot;</span>,icaltime_as_ctime(t));</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    icalfileset_free(fs);</div>
<div class="line">}</div>
<div class="ttc" id="aicalcomponent_8h_html_a23e20161c54d3aeff51e1cc444eee063"><div class="ttname"><a href="icalcomponent_8h.html#a23e20161c54d3aeff51e1cc444eee063">icalcomponent_get_dtstart</a></div><div class="ttdeci">struct icaltimetype icalcomponent_get_dtstart(icalcomponent *comp)</div><div class="ttdoc">Gets the DTSTART property as an icaltime.</div><div class="ttdef"><b>Definition:</b> icalcomponent.c:1406</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md126"></a>
5.4.3 Other routines</h3>
<p>There are several other routines in the icalset interface, but they not fully implemented yet.</p>
<h3><a class="anchor" id="autotoc_md127"></a>
5.5 Memory Management</h3>
<p>Libical relies heavily on dynamic allocation for both the core objects and for the strings used to hold values. Some of this memory the library caller owns and must free, and some of the memory is managed by the library. Here is a summary of the memory rules.</p>
<ol type="1">
<li>If the function name has "new" in it (such as <code><a class="el" href="icalcomponent_8h.html#a601ce104db17e96574387a14a8bcde86" title="Constructor.">icalcomponent_new()</a></code>, or <code>icalproperty_new_from_string()</code>), the caller gets control of the memory. The caller also gets control over an object that is cloned via a function that ends with "_clone" (like <code><a class="el" href="icalcomponent_8h.html#a998b750cba93f9fee6b90f30b5d01fd4" title="Deeply clones an icalcomponent. Returns a pointer to the memory for the newly cloned icalcomponent.">icalcomponent_clone()</a></code>)</li>
<li>If you got the memory from a routine with "clone" or "new" in it, you must call the corresponding <code>*_free()</code> routine to free the memory, for example use <code>icalcomponent_free()</code> to free objects created with <code><a class="el" href="icalcomponent_8h.html#a601ce104db17e96574387a14a8bcde86" title="Constructor.">icalcomponent_new()</a></code> or <code><a class="el" href="icalcomponent_8h.html#a998b750cba93f9fee6b90f30b5d01fd4" title="Deeply clones an icalcomponent. Returns a pointer to the memory for the newly cloned icalcomponent.">icalcomponent_clone()</a></code></li>
<li>If the function name has "add" in it, the caller is transferring control of the memory to the routine, for example the function <code>icalproperty_add_parameter()</code></li>
<li>If the function name has "remove" in it, the caller passes in a pointer to an object and after the call returns, the caller owns the object. So, before you call <code>icalcomponent_remove_property(comp, foo)</code>, you do not own "foo" and after the call returns, you do.</li>
<li>If the routine returns a string and its name does NOT end in <code>_r</code>, libical owns the memory and will put it on a ring buffer to reclaim later. For example, <code>icalcomponent_as_ical_string()</code>. You better <code>strdup()</code> it if you want to keep it, and you don't have to delete it.</li>
<li>If the routine returns a string and its name <em>does</em> end in <code>_r</code>, the caller gets control of the memory and is responsible for freeing it. For example, <code>icalcomponent_as_ical_string_r()</code> does the same thing as <code>icalcomponent_as_ical_string()</code>, except you now have control of the string buffer it returns.</li>
</ol>
<h2><a class="anchor" id="autotoc_md128"></a>
5.6 Error Handling</h2>
<p>Libical has several error handling mechanisms for the various types of programming, semantic and syntactic errors you may encounter.</p>
<h3><a class="anchor" id="autotoc_md129"></a>
5.6.1 Return values</h3>
<p>Many library routines signal errors through their return values. All routines that return a pointer, such as <code><a class="el" href="icalcomponent_8h.html#a601ce104db17e96574387a14a8bcde86" title="Constructor.">icalcomponent_new()</a></code>, will return 0 (zero) on a fatal error. Some routines will return a value of enum <code>icalerrorenum</code>.</p>
<p>5.6.2 <code>icalerrno</code></p>
<p>Most routines will set the global error value <code>icalerrno</code> on errors. This variable is an enumeration; permissible values can be found in <code><a class="el" href="icalerror_8h.html" title="Error handling for libical.">libical/icalerror.h</a></code>. If the routine returns an enum icalerrorenum, then the return value will be the same as icalerrno. You can use <code><a class="el" href="icalerror_8h.html#ace2dcbae58882ed326b4716bf54842cc" title="Finds the description string for error.">icalerror_strerror()</a></code> to get a string that describes the error. The enumerations are:</p>
<ul>
<li><code>ICAL_BADARG_ERROR</code>: One of the arguments to a routine was bad. Typically for a null pointer.</li>
<li><code>ICAL_NEWFAILED_ERROR</code>: A <code>new()</code> or <code>malloc()</code> failed.</li>
<li><code>ICAL_MALFORMEDDATA_ERROR</code>: An input string was not in the correct format</li>
<li><code>ICAL_PARSE_ERROR</code>: The parser failed to parse an incoming component</li>
<li><code>ICAL_INTERNAL_ERROR</code>: Largely equivalent to an assert</li>
<li><code>ICAL_FILE_ERROR</code>: A file operation failed. Check errno for more detail.</li>
<li><code>ICAL_ALLOCATION_ERROR</code>: ?</li>
<li><code>ICAL_USAGE_ERROR</code>: ?</li>
<li><code>ICAL_NO_ERROR</code>: No error</li>
<li><code>ICAL_MULTIPLEINCLUSION_ERROR</code>: ?</li>
<li><code>ICAL_TIMEDOUT_ERROR</code>: For CSTP and acquiring locks</li>
<li><code>ICAL_UNKNOWN_ERROR</code>: ?</li>
</ul>
<h3><a class="anchor" id="autotoc_md130"></a>
5.6.3 &lt;tt&gt;X-LIC-ERROR&lt;/tt&gt; and &lt;tt&gt;X-LIC-INVALID-COMPONENT&lt;/tt&gt;</h3>
<p>The library handles semantic and syntactic errors in components by inserting errors properties into the components. If the parser cannot parse incoming text (a syntactic error) or if the <code><a class="el" href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57" title="Checks if a given VCALENDAR meets all the restrictions imposed by the standard.">icalrestriction_check()</a></code> routine indicates that the component does not meet the requirements of RFC5546 (a semantic error) the library will insert properties of the type <code>X-LIC-ERROR</code> to describe the error. Here is an example of the error property:</p>
<div class="fragment"><div class="line">X-LIC-ERROR;X-LIC-ERRORTYPE=INVALID_ITIP :Failed iTIP restrictions</div>
<div class="line">for property DTSTART.</div>
<div class="line"> </div>
<div class="line">Expected 1 instances of the property and got 0</div>
</div><!-- fragment --><p>This error resulted from a call to <code><a class="el" href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57" title="Checks if a given VCALENDAR meets all the restrictions imposed by the standard.">icalrestriction_check()</a></code>, which discovered that the component does not have a <code>DTSTART</code> property, as required by RFC5545.</p>
<p>There are a few routines to manipulate error properties:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Routine   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void <a class="el" href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57" title="Checks if a given VCALENDAR meets all the restrictions imposed by the standard.">icalrestriction_check()</a></code>   </td><td class="markdownTableBodyNone">Check a component against RFC5546 and insert error properties to indicate non compliance    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int <a class="el" href="icalcomponent_8h.html#aa1f40109577b185be2e807c0f2f00146" title="Returns the number of errors encountered parsing the data.">icalcomponent_count_errors()</a></code>   </td><td class="markdownTableBodyNone">Return the number of error properties in a component    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>void <a class="el" href="icalcomponent_8h.html#a51f8653df2976e849923ae4a93b993fa" title="Removes all X-LIC-ERROR properties.">icalcomponent_strip_errors()</a></code>   </td><td class="markdownTableBodyNone">Remove all error properties in a component    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>void <a class="el" href="icalcomponent_8h.html#a05f04c49a8dcbe21e87fd895cd7fcb3e" title="Converts some X-LIC-ERROR properties into RETURN-STATUS properties.">icalcomponent_convert_errors()</a></code>   </td><td class="markdownTableBodyNone">Convert some error properties into REQUESTS-STATUS proprties to indicate the inability to process the component as an iTIP request.   </td></tr>
</table>
<p>The types of errors are listed in <a class="el" href="icalerror_8h.html" title="Error handling for libical.">icalerror.h</a>. They are:</p>
<ul>
<li><code>ICAL_XLICERRORTYPE_COMPONENTPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PARAMETERVALUEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PARAMETERNAMEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PROPERTYPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_VALUEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_UNKVCALPROP</code></li>
<li><code>ICAL_XLICERRORTYPE_INVALIDITIP</code></li>
</ul>
<p>The libical parser will generate the error that end in <code>PARSEERROR</code> when it encounters garbage in the input steam. <code>ICAL_XLICERRORTYPE_INVALIDITIP</code> is inserted by <code><a class="el" href="icalrestriction_8h.html#a36eeedfdce2344da44fd09d9e3f18b57" title="Checks if a given VCALENDAR meets all the restrictions imposed by the standard.">icalrestriction_check()</a></code>, and <code>ICAL_XLICERRORTYPE_UNKVCALPROP</code> is generated by <code>icalvcal_convert()</code> when it encounters a vCal property that it cannot convert or does not know about.</p>
<p><code><a class="el" href="icalcomponent_8h.html#a05f04c49a8dcbe21e87fd895cd7fcb3e" title="Converts some X-LIC-ERROR properties into RETURN-STATUS properties.">icalcomponent_convert_errors()</a></code> converts some of the error properties in a component into <code>REQUEST-STATUS</code> properties that indicate a failure. As of libical version 0.18, this routine only converts <code>PARSEERROR</code> errors and it always generates a 3.x (failure) code. This makes it more of a good idea than a really useful bit of code.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
5.6.4 &lt;tt&gt;ICAL_ERRORS_ARE_FATAL&lt;/tt&gt; and &lt;tt&gt;icalerror_errors_are_fatal&lt;/tt&gt;</h3>
<p>If <code><a class="el" href="icalerror_8h.html#a44fa677ba623cdcebe9e38b03cd08389" title="Determine if errors are fatal.">icalerror_get_errors_are_fatal()</a></code> returns 1, then any error condition will cause the program to abort. The abort occurs in <code><a class="el" href="icalerror_8h.html#a8266eaa216926b6703a0ef31cd99f0b2" title="Sets the icalerrno to a given error.">icalerror_set_errno()</a></code>, and is done with an assert(0) if NDEBUG is undefined, and with <code><a class="el" href="icalerror_8h.html#a0cbc33f05e014e767bd92b04bfb92f62" title="Triggered to abort the process.">icalerror_crash_here()</a></code> if NDEBUG is defined. Initially, <code><a class="el" href="icalerror_8h.html#a44fa677ba623cdcebe9e38b03cd08389" title="Determine if errors are fatal.">icalerror_get_errors_are_fatal()</a></code> is 1 when <code>ICAL_ERRORS_ARE_FATAL</code> is defined, and 0 otherwise. Since <code>ICAL_ERRORS_ARE_FATAL</code> is defined by default, <code><a class="el" href="icalerror_8h.html#a44fa677ba623cdcebe9e38b03cd08389" title="Determine if errors are fatal.">icalerror_get_errors_are_fatal()</a></code> is also set to 1 by default.</p>
<p>You can change the compiled-in <code>ICAL_ERRORS_ARE_FATAL</code> behavior at runtime by calling <code>icalerror_set_errors_are_fatal(0)</code> (i.e, errors are not fatal) or <code>icalerror_set_errors_are_fatal(1)</code> (i.e, errors are fatal).</p>
<h2><a class="anchor" id="autotoc_md132"></a>
5.7 Naming Standard</h2>
<p>Structures that you access with the "struct" keyword, such as <code>struct icaltimetype</code> are things that you are allowed to see inside and poke at.</p>
<p>Structures that you access though a typedef, such as <code>icalcomponent</code> are things where all of the data is hidden.</p>
<p>Component names that start with "V" are part of RFC5545 or another iCal standard. Component names that start with "X" are also part of the spec, but they are not actually components in the spec. However, they look and act like components, so they are components in libical. Names that start with <code>XLIC</code> or <code>X-LIC</code> are not part of any iCal spec. They are used internally by libical.</p>
<p>Enums that identify a component, property, value or parameter end with <code>_COMPONENT</code>, <code>_PROPERTY</code>, <code>_VALUE</code>, or <code>_PARAMETER</code>"</p>
<p>Enums that identify a parameter value have the name of the parameter as the second word. For instance: <code>ICAL_ROLE_REQPARTICIPANT</code> or <code>ICAL_PARTSTAT_ACCEPTED</code>.</p>
<p>The enums for the parts of a recurrence rule and request statuses are irregular.</p>
<h1><a class="anchor" id="autotoc_md133"></a>
6 Hacks and Bugs</h1>
<p>There are a lot of hacks in the library &ndash; bits of code that I am not proud of and should probably be changed. These are marked with the comment string "HACK."</p>
<h1><a class="anchor" id="autotoc_md134"></a>
7 Library Reference</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
7.1 Manipulating struct icaltimetype</h2>
<h3><a class="anchor" id="autotoc_md136"></a>
7.1.1 Struct icaltimetype</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structicaltimetype.html">icaltimetype</a></div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#a4f64cd87ff0d4aba7bf318485b7374b8">year</a>;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#abfb15dfde907211cafd3cd6cafa5531d">month</a>;</div>
<div class="line">    <span class="keywordtype">int</span> day;</div>
<div class="line">    <span class="keywordtype">int</span> hour;</div>
<div class="line">    <span class="keywordtype">int</span> minute;</div>
<div class="line">    <span class="keywordtype">int</span> second;</div>
<div class="line">    <span class="keywordtype">int</span> is_utc;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="structicaltimetype.html#a48d5ac850b2675cd80bbcefe00d7ae96">is_date</a>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="structicaltimetype.html#aa60ce5ca11223d8d34702962fc7ac57c">zone</a>;</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 9 2022 08:46:36 for Libical API Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
